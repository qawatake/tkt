package main

import (
	_ "embed"
	"fmt"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

type Language struct {
	Type    string   `yaml:"type"`
	Color   string   `yaml:"color"`
	Aliases []string `yaml:"aliases"`
}

type Languages map[string]Language

//go:embed languages.yml
var languagesData []byte

//go:embed normalized.txt
var normalizedData []byte

func main() {
	if len(os.Args) < 2 {
		log.Fatalf("Usage: %s <package_name>", os.Args[0])
	}

	packageName := os.Args[1]

	var languages Languages
	if err := yaml.Unmarshal(languagesData, &languages); err != nil {
		log.Fatalf("Failed to parse languages.yml: %v", err)
	}

	targetLanguages := extractTargetLanguages(string(normalizedData))

	// Debug: output target languages to stderr
	fmt.Fprintf(os.Stderr, "Found %d target languages:\n", len(targetLanguages))
	for langName, targetKey := range targetLanguages {
		fmt.Fprintf(os.Stderr, "  %s -> %s\n", langName, targetKey)
	}
	fmt.Fprintf(os.Stderr, "\n")

	mapping := generateLanguageMapping(languages, targetLanguages)

	// Generate Go code and output to stdout
	content := generateGoCode(mapping, packageName)

	fmt.Print(content)
}

func generateGoCode(mapping map[string]string, packageName string) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated language mapping\n")
	sb.WriteString("// DO NOT EDIT - generated by internal/scripts/maplang/main.go\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	sb.WriteString("import \"strings\"\n\n")
	sb.WriteString("var languageMap = map[string]string{\n")

	var keys []string
	for k := range mapping {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		sb.WriteString(fmt.Sprintf("\t%q: %q,\n", key, mapping[key]))
	}

	sb.WriteString("}\n\n")

	// Add the NormalizeLanguage function
	sb.WriteString("// NormalizeLanguage normalizes a language identifier to a standardized form.\n")
	sb.WriteString("// It returns the normalized language name if found in the mapping, otherwise returns the original.\n")
	sb.WriteString("func NormalizeLanguage(lang string) string {\n")
	sb.WriteString("\tif lang == \"\" {\n")
	sb.WriteString("\t\treturn \"\"\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\t\n")
	sb.WriteString("\t// Convert to lowercase and replace spaces with underscores\n")
	sb.WriteString("\tnormalized := strings.ToLower(strings.ReplaceAll(lang, \" \", \"_\"))\n")
	sb.WriteString("\t\n")
	sb.WriteString("\t// Look up in the language map\n")
	sb.WriteString("\tif mappedLang, exists := languageMap[normalized]; exists {\n")
	sb.WriteString("\t\treturn mappedLang\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\t\n")
	sb.WriteString("\t// If not found, return the original language\n")
	sb.WriteString("\treturn lang\n")
	sb.WriteString("}\n")

	return sb.String()
}

func extractTargetLanguages(lllContent string) map[string]string {
	targetLanguages := make(map[string]string)

	re := regexp.MustCompile(`^\s*\d*â†’?\s*([^(]+)\s*\(([^)]+)\)`)

	lines := strings.Split(lllContent, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		if matches := re.FindStringSubmatch(line); len(matches) == 3 {
			languageName := strings.TrimSpace(matches[1])
			languageKey := strings.TrimSpace(matches[2])
			targetLanguages[languageName] = languageKey
		}
	}

	return targetLanguages
}

func generateLanguageMapping(languages Languages, targetLanguages map[string]string) map[string]string {
	mapping := make(map[string]string)

	for langName, targetKey := range targetLanguages {
		normalizedKey := strings.ToLower(targetKey)

		// Add the normalized key itself (e.g., "go" -> "go")
		mapping[normalizedKey] = normalizedKey

		// Try exact match first
		if langDef, exists := languages[langName]; exists {
			for _, alias := range langDef.Aliases {
				normalizedAlias := strings.ToLower(strings.ReplaceAll(alias, " ", "_"))
				mapping[normalizedAlias] = normalizedKey
			}
			continue
		}

		// Try case-insensitive match
		for yamlLangName, langDef := range languages {
			if strings.EqualFold(yamlLangName, langName) {
				for _, alias := range langDef.Aliases {
					normalizedAlias := strings.ToLower(strings.ReplaceAll(alias, " ", "_"))
					mapping[normalizedAlias] = normalizedKey
				}
				break
			}
		}
	}

	return mapping
}
